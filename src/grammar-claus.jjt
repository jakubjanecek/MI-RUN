/*---------------------------------------------------------------------------*
 * Options                                                                   *
 *---------------------------------------------------------------------------*/

 options {
  //DEBUG_PARSER = true;
  STATIC = false;
  MULTI = true;
}

/*---------------------------------------------------------------------------*
 * Parser                                                                    *
 *---------------------------------------------------------------------------*/

PARSER_BEGIN(Claus)

import java.util.ArrayList;
import vm.mm.*;

class Claus {
  public static MM mem;
  public static vm.ClausVM vim;
  public ArrayList<String> codeLines;
  public Pointer inputClass;
  public boolean inMethod = false;
  public int localVars = 0;
  
  public static void main(String[] args) {
    try {
      // VM init
      int size = 1024;
      mem = new MM(size, size, size);
      vim = new vm.ClausVM(mem);
      
      // Input parsing
      Claus parser = new Claus(System.in);
      System.out.println(parser.Class());
      System.out.println("\nParsing result: OK.");
    } catch (ParseException pe) {
      System.err.println("\nParse exception occured.");
    } catch (TokenMgrError tme) {
      System.err.println("\nToken exception occured.");
    } catch (Exception e) {
      System.err.println("\nException occured: " + e.getMessage());
    }
  }
}

PARSER_END(Claus)

/*---------------------------------------------------------------------------*
 * Grammar                                                                   *
 *---------------------------------------------------------------------------*/

/* Whitespaces */
SKIP: {
    " "
  | "\t"
  | "\n"
  | "\r"
}

/* Comments */
MORE:
{
  "//": IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); }: IN_FORMAL_COMMENT
|
  "/*": IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN:
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" >: DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN:
{
  <FORMAL_COMMENT: "*/" >: DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN:
{
  <MULTI_LINE_COMMENT: "*/" >: DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE:
{
  < ~[] >
}

/* Tokens */
TOKEN: {
    <CLASS_KW: "class">
  | <ENTRYPOINT_KW: "entry-point">
  | <DEF_KW: "def">
  | <VAR_KW: "var">
  | <RETURN_KW: "return">
  | <RETURN_VALUE_KW: "retval">
  | <NEW_KW: "new">
  | <FOR_KW: "for">
  | <FOR_ARROW_KW: "<-">
  | <WHILE_KW: "while">
  | <IF_KW: "if">
  | <ELSE_KW: "else">
  | <TRUE_KW: "true">
  | <FALSE_KW: "false">
  | <LBRACE: "{">
  | <RBRACE: "}">
  | <LPAREN: "(">
  | <RPAREN: ")">
  | <LBRACKET: "[">
  | <RBRACKET: "]">
  | <COLON: ":">
  | <SEMI: ";">
  | <COMMA: ",">
  | <PERIOD: ".">
  | <DECLARATION_EQUALS: "=">
  | <PLUS: "+">
  | <MINUS: "-">
  | <MULTIPLICATION: "*">
  | <DIVISION: "/">
  | <MODULO: "%">
  | <POWER: "^">
  | <EQUALS: "==">
  | <NOT_EQUALS: "!=">
  | <LT: "<">
  | <GT: ">">
  | <ID: ["a"-"z","A"-"Z"](["a"-"z","A"-"Z","0"-"9"])*>
  | <STRING: "\""(~["\""])*"\"">
  | <INTEGER: (["0"-"9"])+>
}

/*---------------------------------------------------------------------------*
 * AST nodes                                                                 *
 *---------------------------------------------------------------------------*/

//* Class */
ASTClass Class():
{
  Token className;
}
{
  <CLASS_KW> className=<ID> <LBRACE> ClassBody() <RBRACE>
  <EOF>
  {
    inputClass = vim.newClazz(vm.Util.str2bytes(className.image), 0);
    jjtThis.value = className.image;
    return jjtThis;
  }
}

//* Class body */
void ClassBody():
{}
{
  (Declaration())*
  {
  }
}

/* Declaration */
void Declaration():
{
  //System.out.println("[DECLARATION]");
}
{
    VariableDeclaration()
  | MethodDeclaration()
  | EntryPoint()
  {
  }
}

//* Entry-point */
void EntryPoint():
{
  System.out.println("[ENTRY-POINT] BEGIN.");
  CodePointer cp;
}
{
  <ENTRYPOINT_KW> <LBRACE> cp=MethodBody() <RBRACE>
  {
    vim.run(cp);
    System.out.println("[ENTRY-POINT] END.");
  }
}

/* Method declaration */
void MethodDeclaration():
{
  Token methodName;
  CodePointer cp;
  localVars = 0;
}
{
  <DEF_KW> methodName=<ID> <LPAREN> MethodArgumentDeclarationList() <RPAREN> TypeSpecifier() <DECLARATION_EQUALS> <LBRACE>
    cp=MethodBody()
  <RBRACE>
  {
    System.out.println("[METHOD DECLARATION]: localVars=" + localVars);
    vim.newMethod(methodName.image, cp, localVars);
    // TODO - Zavolat vytvoreni metody.
    //Pointer cmp = vim.newMethodDictionary(asList(new Integer[]{vim.newMethod(methodName.image, cp, 0)}));
    //classCar.$c().methods(cmp);
  }
}

/* Method argument declaration list */
void MethodArgumentDeclarationList():
{}
{
   [MethodArgumentDeclaration() MethodArgumentDeclarationListExt()]
}

/* Method argument declaration list extension */
void MethodArgumentDeclarationListExt():
{}
{
  [<COMMA> MethodArgumentDeclarationList()]
}

/* Method argument declaration */
void MethodArgumentDeclaration():
{}
{
  <ID> TypeSpecifier()
}

/* Method body */
CodePointer MethodBody():
{
  inMethod = true;
  CodePointer cp;
}
{
  cp=Block()
  {
    
    System.out.println("[METHOD BODY] END.");
    inMethod = false;
    return cp;
  }
}

/* Block */
CodePointer Block():
{}
{
  (Statement())*
  {
    // TODO - FIXME.
    String[] code = new String[]{
      "new-int 10",
      "new-int 20",
      "call " + mem.addConstant("add"),
      "syscall " + vm.Syscalls.calls2ints.get("print-int"),
      "return"
    };
    return mem.storeCode(vm.Util.translateBytecode(code));
  }
}

/* Variable declaration */
void VariableDeclaration():
{
  Token varName;
  //String s;
}
{
  <VAR_KW> varName=<ID> [TypeSpecifier()] <DECLARATION_EQUALS> Expression()
  {
    //System.out.println("DEKLARACE PROMENNE: " + varName.image + "=" + s);
    System.out.println("VARIABLE DECLARATION: " + varName.image + "=<EXPRESSION>");
    if (inMethod) {
      localVars++;
    }
  }
}

/* Type specifier */
void TypeSpecifier():
{}
{
  <COLON> <ID> [<LBRACKET> <RBRACKET>]
}

/* Statement */
void Statement():
{}
{
    LOOKAHEAD(2)
    MethodCall()
  | VariableDeclaration()
  | Assignment()
  | ReturnStatement()
  | ReturnValueStatement()
  | If()
  | While()
  | For()
  {
    System.out.println("<STATEMENT>");
  }
}

/* Expression */
void Expression():
{}
{
    LOOKAHEAD(2)
    MathExpression()
  | Instantiation()
  | SimpleValue()
  {
    System.out.println("<EXPRESSION>");
    //return ("EXPRESSION: " + s);
    //codeLines.add("EXPRESSION: " + s);
  }
}

/* Method call */
void MethodCall():
{
  Token t;
}
{
    LOOKAHEAD(2)
    <ID> <PERIOD> t=<ID> <LPAREN> [MethodArgumentList()] <RPAREN>
  | t=<ID> <LPAREN> [MethodArgumentList()] <RPAREN>
  {
    //return ("METHOD CALL: " + t.image);
    System.out.println("METHOD CALL: " + t.image);
  }
}

/* Mathod argument list */
void MethodArgumentList():
{
  //String s1;
  //String s2;
}
{
  Expression() MethodArgumentListExtension()
  {
    //System.out.println("METHOD ARGUMENT LIST: (" + s1 + s2 + ")");
  }
}

/* Mathod argument list extension */
void MethodArgumentListExtension():
{
  //String s = "";
  //String a = "";
}
{
  (<COMMA> Expression())*
  {
  }
}

/* Instantiation */
void Instantiation():
{
  //Token t;
}
{
  <NEW_KW> <ID> ArrayIndexing()
  {
    System.out.println("<INSTANTIATION>");
  }
}

/* Assignment */
void Assignment():
{
  Token t;
}
{
  t=<ID> ArrayIndexing() <DECLARATION_EQUALS> Expression()
  {
    System.out.println("ASSIGNMENT: " + t.image);
  }
}

/* Return statement */
void ReturnStatement():
{}
{
  <RETURN_KW>
  {
    System.out.println("RETURN");
  }
}

/* Return-value statement */
void ReturnValueStatement():
{}
{
  <RETURN_VALUE_KW> Expression()
  {
    System.out.println("RETURN-VALUE");
  }
}

/* If condition */
void If():
{
  CodePointer cp;
}
{
  <IF_KW> <LPAREN> Condition() <RPAREN> <LBRACE> cp=Block() <RBRACE>
  [<ELSE_KW> <LBRACE> cp=Block() <RBRACE>]
  {
  }
}

/* While loop */
void While():
{
  CodePointer cp;
}
{
  <WHILE_KW> <LPAREN> Condition() <RPAREN> <LBRACE> cp=Block() <RBRACE>
  {
  }
}

/* For loop */
void For():
{
  CodePointer cp;
}
{
  <FOR_KW> <LPAREN> ForDeclaration() <RPAREN> <LBRACE> cp=Block() <RBRACE>
}

/* For loop declaration */
void ForDeclaration():
{
  Token t;
  //String s1;
  //String s2;
}
{
  t=<ID> <FOR_ARROW_KW> Expression() <PERIOD> <PERIOD> Expression()
  {
    System.out.println("FOR-LOOP: " + t.image);
  }
}

/* Contition */
void Condition():
{
  Token t;
  //String s1;
  //String s2;
}
{
  Expression() (t=<EQUALS> | t=<NOT_EQUALS> | t=<LT> | t=<GT>) Expression()
  {
    System.out.println("CONDITION: TYPE " + t.image);
  }
}

/* Simple value */
void SimpleValue():
{}
{
    LOOKAHEAD(2)
    MethodCall()
  | Indexer()
  | IntegerValue()
  | TrueValue()
  | FalseValue()
  | StringValue()
  {
    System.out.println ("<SIMPLE VALUE>");
  }
}

/* Integer value */
void IntegerValue():
{
  Token t;
}
{
  t=<INTEGER>
  {
    System.out.println("INTEGER: " + t.image);
  }
}

/* True value */
void TrueValue():
{
  Token t;
}
{
  t=<TRUE_KW>
  {
    System.out.println("TRUE: " + t.image);
  }
}

/* False value */
void FalseValue():
{
  Token t;
}
{
  t=<FALSE_KW>
  {
    System.out.println("INTEGER: " + t.image);
  }
}

/* String value */
void StringValue():
{
  Token t;
}
{
  t=<STRING>
  {
    System.out.println("INTEGER: " + t.image);
  }
}

/* Array */
void Indexer():
{
  //Token t;
}
{
  <ID> ArrayIndexing()
  {
    //return t;
  }
}

/* Array indexing */
void ArrayIndexing():
{
  //Token t;
}
{
  [<LBRACKET> Expression() <RBRACKET>]
  {
    System.out.println("[<EXPRESSION>]");
  }
}

/* Math expression */
void MathExpression():
{}
{
  <LPAREN> Term() MathExpressionExt() <RPAREN>
  {
    System.out.println("<MATH EXPRESSION>");
  }
}

/* Math expression extension */
void MathExpressionExt():
{}
{
  [(<PLUS> | <MINUS>) Term() MathExpressionExt()]
}

/* Term */
void Term():
{}
{
  Factor() TermExt()
}

/* Term extension */
void TermExt():
{}
{
  [(<MULTIPLICATION> | <DIVISION> | <MODULO> | <POWER>) Factor() TermExt()]
}

/* Factor */
void Factor():
{}
{
  <INTEGER> | <ID> | MathExpression()
}
