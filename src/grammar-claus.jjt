options {
  //DEBUG_PARSER = true;
  STATIC = false;
  MULTI = true;
}

PARSER_BEGIN(Claus)

import vm.mm.*;

class Claus {
  public static MM mem;
  public static vm.ClausVM vim;
  public Pointer inputClass;
  
  public static void main(String[] args) {
    try {
      // VM init
      int size = 1024;
      mem = new MM(size, size, size);
      vim = new vm.ClausVM(mem);
      
      // Input parsing
      Claus parser = new Claus(System.in);
      System.out.println(parser.Class());
      System.out.println("Parsing result: OK.");
    } catch (ParseException pe) {
      System.err.println("Parse exception occured.");
    } catch (TokenMgrError tme) {
      System.err.println("Token exception occured.");
    } catch (Exception e) {
      System.err.println("Exception occured: " + e.getMessage());
    }
  }
}

PARSER_END(Claus)

SKIP: {" " | "\n" | "\r" | "\t"}

TOKEN: {
  <CLASS_KW: "class">
| <ENTRYPOINT_KW: "entry-point">
| <DEF_KW: "def">
| <VAR_KW: "var">
| <RETURN_KW: "return">
| <NEW_KW: "new">
| <FOR_KW: "for">
| <FOR_ARROW_KW: "<-">
| <WHILE_KW: "while">
| <IF_KW: "if">
| <ELSE_KW: "else">
| <TRUE_KW: "true">
| <FALSE_KW: "false">
| <LBRACE: "{">
| <RBRACE: "}">
| <LPAREN: "(">
| <RPAREN: ")">
| <LBRACKET: "[">
| <RBRACKET: "]">
| <COLON: ":">
| <SEMI: ";">
| <COMMA: ",">
| <PERIOD: ".">
| <DECLARATION_EQUALS: "=">
| <PLUS: "+">
| <MINUS: "-">
| <MULTIPLICATION: "*">
| <DIVISION: "/">
| <MODULO: "%">
| <POWER: "^">
| <EQUALS: "==">
| <NOT_EQUALS: "!=">
| <LT: "<">
| <GT: ">">
| <ID: ["a"-"z","A"-"Z"](["a"-"z","A"-"Z","0"-"9"])*>
| <STRING: "\""(~["\""])*"\"">
| <INTEGER: (["0"-"9"])+>
}

ASTClass Class():
{
  Token className;
}
{
  <CLASS_KW> className=<ID> <LBRACE> ClassBody() <RBRACE>
  <EOF>
  {
    // VM
    inputClass = vim.newClazz(vm.Util.str2bytes(className.image), 0);
    // JJTree
    jjtThis.value = className.image;
    return jjtThis;
  }
}

void ClassBody():
{}
{
  (Declaration())*
}

void Declaration():
{}
{
  VariableDeclaration() | MethodDeclaration() | EntryPoint()
}

/* Entry-point */
void EntryPoint():
{
  String[] code;
}
{
  <ENTRYPOINT_KW> <LBRACE> code=MethodBody() <RBRACE>
  {
    vim.run(mem.storeCode(vm.Util.translateBytecode(code)));
  }
}

void MethodDeclaration():
{
  Token methodName;
  String[] code;
}
{
  <DEF_KW> methodName=<ID> <LPAREN> MethodArgumentDeclarationList() <RPAREN> TypeSpecifier() <DECLARATION_EQUALS> <LBRACE>
    code=MethodBody()
  <RBRACE>
  {
    // TODO - Zavolat vytvoreni metody.
  }
}

void MethodArgumentDeclarationList():
{}
{
   [MethodArgumentDeclaration() MethodArgumentDeclarationListExt()]
}

void MethodArgumentDeclarationListExt():
{}
{
  [<COMMA> MethodArgumentDeclarationList()]
}

void MethodArgumentDeclaration():
{}
{
  <ID> TypeSpecifier()
}

/* Method body */
String[] MethodBody():
{}
{
  Block()
  {
    String[] code = new String[]{
            "new-int 10",
            "new-int 20",
            "call " + mem.addConstant("add"),
            "syscall " + vm.Syscalls.calls2ints.get("print-int"),
            "return"
    };
    return code;
  }
}

void Block():
{}
{
  (Statement())*
}

void VariableDeclaration():
{}
{
  <VAR_KW> <ID> [TypeSpecifier()] <DECLARATION_EQUALS> Expression()
}

void TypeSpecifier():
{}
{
  <COLON> <ID> [<LBRACKET> <RBRACKET>]
}

void Statement():
{}
{
  LOOKAHEAD(2)
  MethodCall()
| VariableDeclaration()
| Assignment()
| Return()
| If()
| While()
| For()
}

void Expression():
{}
{
  LOOKAHEAD(2)
  MathExpression()
| Instantiation()
| SimpleValue()
}

void MethodCall():
{}
{
  LOOKAHEAD(2)
  <ID> <PERIOD> <ID> <LPAREN> [MethodArgumentList()] <RPAREN>
| <ID> <LPAREN> [MethodArgumentList()] <RPAREN>
}

void MethodArgumentList():
{}
{
  Expression() (<COMMA> Expression())*
}

void Instantiation():
{}
{
  <NEW_KW> <ID> ArrayIndexing()
}

void Assignment():
{}
{
  <ID> ArrayIndexing() <DECLARATION_EQUALS> Expression()
}

void Return():
{}
{
  <RETURN_KW> Expression()
}

void If():
{}
{
  <IF_KW> <LPAREN> Condition() <RPAREN>
    <LBRACE> Block() <RBRACE>
    [<ELSE_KW> <LBRACE> Block() <RBRACE>]
}

void While():
{}
{
  <WHILE_KW> <LPAREN> Condition() <RPAREN> <LBRACE> Block() <RBRACE>
}

void For():
{}
{
  <FOR_KW> <LPAREN> ForDeclaration() <RPAREN> <LBRACE> Block() <RBRACE>
}

void ForDeclaration():
{}
{
  <ID> <FOR_ARROW_KW> Expression() <PERIOD> <PERIOD> Expression()
}

void Condition():
{}
{
  Expression() (<EQUALS> | <NOT_EQUALS> | <LT> | <GT>) Expression()
}

void SimpleValue():
{}
{
  LOOKAHEAD(2)
  MethodCall()
| <ID> ArrayIndexing()
| <INTEGER>
| <TRUE_KW>
| <FALSE_KW>
| <STRING>
}

void ArrayIndexing():
{}
{
  [<LBRACKET> Expression() <RBRACKET>]
}

void MathExpression():
{}
{
  <LPAREN> Term() MathExpressionExt() <RPAREN>
}

void MathExpressionExt():
{}
{
  [(<PLUS> | <MINUS>) Term() MathExpressionExt()]
}

void Term():
{}
{
  Factor() TermExt()
}

void TermExt():
{}
{
  [(<MULTIPLICATION> | <DIVISION> | <MODULO> | <POWER>) Factor() TermExt()]
}

void Factor():
{}
{
  <INTEGER> | <ID> | MathExpression()
}
